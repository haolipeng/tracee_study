# 核心概念通俗解释

> 本文档用通俗易懂的方式解释 eBPF 安全检测中的核心概念，帮助你快速建立知识框架。

---

## 目录

1. [eBPF 是什么](#1-ebpf-是什么)
2. [Linux 权限模型](#2-linux-权限模型)
3. [Hook 点和探针类型](#3-hook-点和探针类型)
4. [BPF Maps 数据结构](#4-bpf-maps-数据结构)
5. [容器与隔离机制](#5-容器与隔离机制)
6. [检测工具架构](#6-检测工具架构)

---

## 1. eBPF 是什么

### 1.1 一句话解释

**eBPF 是一种在内核中安全运行自定义程序的技术，无需修改内核代码或加载内核模块。**

### 1.2 类比理解

想象 Linux 内核是一座大楼：

```
传统方式：想在大楼里装监控？
  → 要么重新盖楼（修改内核源码）
  → 要么打洞装设备（加载内核模块）
  → 风险大、门槛高

eBPF 方式：
  → 大楼预留了标准接口（hook 点）
  → 你只需要插入符合规范的小设备（eBPF 程序）
  → 内核会检查设备安全性（verifier）
  → 安全、灵活、无需重启
```

### 1.3 eBPF 程序的生命周期

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  编写代码   │ ──▶ │  编译为字节码 │ ──▶ │  加载到内核  │
│  (.c 文件)  │     │  (.o 文件)  │     │             │
└─────────────┘     └─────────────┘     └──────┬──────┘
                                               │
                                               ▼
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  数据传回   │ ◀── │  触发执行   │ ◀── │ Verifier验证│
│  用户空间   │     │ (事件发生时) │     │  (安全检查)  │
└─────────────┘     └─────────────┘     └─────────────┘
```

### 1.4 eBPF 能做什么

| 领域 | 应用 | 代表工具 |
|------|------|----------|
| **安全监控** | 检测入侵、提权、可疑行为 | Tracee、Falco、Tetragon |
| **网络** | 负载均衡、防火墙、流量分析 | Cilium、Katran |
| **性能分析** | CPU、内存、IO 分析 | bpftrace、perf |
| **可观测性** | 分布式追踪 | Pixie |

### 1.5 关键限制

eBPF 程序有严格限制（为了安全）：

| 限制 | 说明 |
|------|------|
| 栈大小 | 最大 512 字节 |
| 指令数 | 最大 100 万条（旧内核更少） |
| 循环 | 必须有边界（不能无限循环） |
| 内存访问 | 必须通过辅助函数（如 bpf_probe_read） |
| 调用深度 | 有限的函数调用层级 |

---

## 2. Linux 权限模型

### 2.1 核心问题

**内核如何判断一个进程能做什么？**

答案是：每个进程都有一个「身份证」，叫做 **cred（凭证）结构**。

### 2.2 进程的「身份证」

```
┌────────────────────────────────────────────┐
│              struct cred（凭证）            │
├────────────────────────────────────────────┤
│                                            │
│  UID 相关：                                 │
│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐      │
│  │ uid  │ │ euid │ │ suid │ │fsuid │      │
│  │ 真实 │ │ 有效 │ │ 保存 │ │文件系统│      │
│  └──────┘ └──────┘ └──────┘ └──────┘      │
│                                            │
│  GID 相关：                                 │
│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐      │
│  │ gid  │ │ egid │ │ sgid │ │fsgid │      │
│  └──────┘ └──────┘ └──────┘ └──────┘      ��
│                                            │
│  Capabilities（能力）：                     │
│  ┌────────────┐ ┌────────────┐             │
│  │ permitted  │ │ effective  │ ...         │
│  │ 允许拥有的 │ │ 当前生效的 │             │
│  └────────────┘ └────────────┘             │
│                                            │
└────────────────────────────────────────────┘
```

### 2.3 各种 UID 的区别

| UID 类型 | 作用 | 举例 |
|----------|------|------|
| **uid（真实UID）** | 标识「谁启动了这个进程」 | 你登录的用户 |
| **euid（有效UID）** | **决定大多数权限检查** | SUID 程序执行时会变 |
| **suid（保存UID）** | 用于临时降权后恢复 | sudo 内部使用 |
| **fsuid（文件系统UID）** | 文件操作的权限判断 | 通常等于 euid |

**关键理解**：
- **euid = 0 意味着 root 权限**
- 大多数权限检查看的是 euid，不是 uid

### 2.4 一个例子：passwd 命令

```bash
$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root ... /usr/bin/passwd
   ↑
   s 表示 SUID 位
```

当普通用户执行 passwd 时：

```
执行前：uid=1000, euid=1000（普通用户）
    │
    ▼ 执行 SUID 程序
    │
执行时：uid=1000, euid=0（有效权限变成 root）
    │
    ▼ 可以修改 /etc/shadow
```

**这就是 SUID 提权的原理：通过 SUID 程序获得 euid=0。**

### 2.5 什么是提权

**提权 = 通过某种方式让进程的 euid 变成 0（或获得高危 capabilities）**

正常提权：
- sudo、su 等授权程序
- SUID 程序的设计用途

恶意提权：
- 利用 SUID 程序的漏洞
- 利用内核漏洞直接修改 cred 结构
- 利用配置错误

### 2.6 commit_creds：提权的「必经之路」

无论通过什么方式提权，最终都要调用 `commit_creds()` 函数让新凭证生效：

```
      正常路径                     恶意路径
         │                           │
    sudo/setuid                  内核漏洞利用
         │                           │
         ▼                           ▼
    prepare_creds()  ◀───────────────┘
    （准备新凭证）
         │
         ▼
    commit_creds()  ◀─── 这里 hook！
    （让新凭证生效）
         │
         ▼
    权限变化完成
```

**所以检测提权最好的 hook 点就是 commit_creds！**

---

## 3. Hook 点和探针类型

### 3.1 什么是 Hook

**Hook = 在某个位置「埋点」，当程序执行到这里时触发你的代码**

类比：在门口装一个感应器，有人进出就触发报警。

### 3.2 主要探针类型

```
┌─────────────────────────────────────────────────────────────┐
│                      内核空间                               │
│                                                             │
│   Tracepoint           Kprobe              LSM Hook         │
│   ┌─────────┐         ┌─────────┐         ┌─────────┐      │
│   │ 预埋的  │         │ 动态的  │         │ 安全    │      │
│   │ 探测点  │         │ 函数hook│         │ 检查点  │      │
│   └─────────┘         └─────────┘         └─────────┘      │
│       │                   │                   │            │
│       ▼                   ▼                   ▼            │
│   系统调用入口        任意内核函数       安全决策点          │
│   sys_enter_*         commit_creds      security_file_open │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 探针类型对比

| 类型 | 特点 | 适用场景 | 稳定性 |
|------|------|----------|--------|
| **Tracepoint** | 内核预定义的探测点 | 系统调用监控 | 高（稳定 ABI） |
| **Kprobe** | 可 hook 任意内核函数 | 内部函数监控（如 commit_creds） | 中（函数可能变化） |
| **Kretprobe** | hook 函数返回 | 获取函数返回值 | 中 |
| **LSM Hook** | 安全模块检查点 | 安全检测、可拦截 | 高（需内核支持） |
| **Uprobe** | hook 用户态函数 | 应用层监控 | 依赖应用 |

### 3.4 如何选择 Hook 点

```
检测需求 ──────────────────────────────────────▶ Hook 点选择

监控系统调用（如 execve）       ──▶  tracepoint/syscalls/sys_enter_execve
监控内核函数（如 commit_creds） ──▶  kprobe/commit_creds
监控文件访问（需要路径信息）    ──▶  lsm/security_file_open
监控函数返回值                  ──▶  kretprobe
```

### 3.5 一个具体例子

**需求**：检测进程的 UID 变化

| 方案 | Hook 点 | 优点 | 缺点 |
|------|---------|------|------|
| 方案 A | tracepoint/sys_enter_setuid | 稳定 | 只能看到请求，不知道是否成功 |
| 方案 B | kprobe/__x64_sys_setuid | 灵活 | 同上，且函数名可能变 |
| **方案 C** | **kprobe/commit_creds** | **一个点覆盖所有** | 内部函数 |

**选择方案 C**，因为 commit_creds 是所有权限变化的必经之路。

---

## 4. BPF Maps 数据结构

### 4.1 什么是 BPF Maps

**BPF Maps = eBPF 程序和用户空间程序之间共享的数据结构**

类比：一个双方都能读写的「公告板」。

```
┌────────────────┐                    ┌────────────────┐
│   用户空间      │                    │   内核空间      │
│                │                    │                │
│  Go/Python程序 │ ◀───── 读写 ─────▶ │   eBPF 程序    │
│                │                    │                │
└────────────────┘                    └────────���───────┘
                        │
                        ▼
               ┌────────────────┐
               │   BPF Maps     │
               │  ┌──────────┐  │
               │  │ key: val │  │
               │  │ key: val │  │
               │  │ key: val │  │
               │  └──────────┘  │
               └────────────────┘
```

### 4.2 常见 Map 类型

| 类型 | 说明 | 使用场景 |
|------|------|----------|
| **Hash Map** | key-value 存储 | 进程信息缓存、配置数据 |
| **Array** | 固定大小数组 | 索引访问、统计计数 |
| **LRU Hash** | 自动淘汰旧数据 | 连接追踪、DNS 缓存 |
| **Per-CPU Hash** | 每个 CPU 独立 | 高性能计数器 |
| **Perf Event Array** | 事件传递 | 向用户空间发送事件 |
| **Ring Buffer** | 环形缓冲区 | 高效事件传递（新内核） |

### 4.3 一个具体例子

**需求**：记录进程的执行次数

```c
// 定义 Map：key 是进程名，value 是计数
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1024);
    __type(key, char[16]);    // 进程名
    __type(value, u64);       // 计数
} exec_count SEC(".maps");

// 在 eBPF 程序中使用
SEC("tracepoint/syscalls/sys_enter_execve")
int trace_execve(void *ctx) {
    char comm[16];
    bpf_get_current_comm(&comm, sizeof(comm));

    u64 *count = bpf_map_lookup_elem(&exec_count, &comm);
    if (count) {
        (*count)++;
    } else {
        u64 init = 1;
        bpf_map_update_elem(&exec_count, &comm, &init, BPF_ANY);
    }
    return 0;
}
```

### 4.4 Perf Buffer：事件传递

```
内核空间                              用户空间
   │                                     │
   │  ┌─────────────────────────────┐    │
   │  │      Perf Event Array       │    │
   │  │  ┌───┐ ┌───┐ ┌───┐ ┌───┐   │    │
   │──▶│ E1│ │ E2│ │ E3│ │...│ ──────▶│  持续读取
   │  │  └───┘ └───┘ └───┘ └───┘   │    │
   │  └─────────────────────────────┘    │
   │                                     │
   │  bpf_perf_event_output()           │  poll/epoll
```

---

## 5. 容器与隔离机制

### 5.1 容器不是虚拟机

```
虚拟机：                          容器：
┌─────────────────────┐          ┌─────────────────────┐
│   App     App       │          │   App     App       │
├─────────────────────┤          ├─────────────────────┤
│   Guest OS          │          │ 隔离的视图（namespace）│
├─────────────────────┤          │   共享的内核          │
│   Hypervisor        │          ├─────────────────────┤
├─────────────────────┤          │   Host OS            │
│   Host OS           │          └─────────────────────┘
└─────────────────────┘

完全隔离，各有内核                 共享内核，隔离视图
```

**关键理解：容器与宿主机共享同一个内核，这就是容器逃逸可能发生的原因。**

### 5.2 Namespace：隔离「看到什么」

| Namespace | 隔离什么 | 效果 |
|-----------|----------|------|
| **Mount** | 文件系统挂载点 | 容器看不到宿主机文件 |
| **PID** | 进程 ID | 容器内 PID 1 是容器进程 |
| **Network** | 网络设备、端口 | 容器有独立网络栈 |
| **UTS** | 主机名 | 容器有独立主机名 |
| **User** | 用户 ID | 容器内 root ≠ 宿主机 root |
| **Cgroup** | cgroup 根目录 | 看不到其他容器的 cgroup |

### 5.3 Cgroup：限制「能用多少」

```
Cgroup 控制的资源：

┌─────────────────────��──────────────────┐
│  CPU      │  限制 CPU 使用率           │
├───────────┼────────────────────────────┤
│  Memory   │  限制内存使用量            │
├───────────┼────────────────────────────┤
│  IO       │  限制磁盘读写速度          │
├───────────┼────────────────────────────┤
│  PIDs     │  限制进程数量              │
└───────────┴────────────────────────────┘
```

### 5.4 如何判断进程是否在容器中

**方法 1：通过 cgroup 路径**

```bash
# 宿主机进程的 cgroup
/sys/fs/cgroup/memory/user.slice/...

# Docker 容器进程的 cgroup
/sys/fs/cgroup/memory/docker/<container-id>/...
```

**方法 2：通过 namespace**

```bash
# 比较进程的 namespace 和 PID 1 的 namespace
ls -la /proc/self/ns/
ls -la /proc/1/ns/

# 如果不同，说明在容器中
```

**在 eBPF 中**：

```c
// 获取 cgroup ID
u64 cgroup_id = bpf_get_current_cgroup_id();

// 通过 cgroup ID 判断是否为容器
// 需要用户空间配合维护 cgroup -> container 的映射
```

### 5.5 容器逃逸的本质

```
正常情况：
┌─────────────────────────────────────┐
│  容器                               │
│  ┌───────────────────────────────┐ │
│  │ 进程只能看到/操作隔离后的视图  │ │
│  └───────────────────────────────┘ │
└─────────────────────────────────────┘
        │ namespace/cgroup 边界
        ▼
┌─────────────────────────────────────┐
│  宿主机                             │
└─────────────────────────────────────┘

容器逃逸：
┌─────────────────────────────────────┐
│  容器                               │
│  ┌───────────────────────────────┐ │
│  │ 进程突破隔离边界              │──┼──▶ 访问宿主机资源
│  └───────────────────────────────┘ │
└─────────────────────────────────────┘
```

---

## 6. 检测工具架构

### 6.1 基本架构

```
┌─────────────────────────────────────────────────────────┐
│                       用户空间                          │
│                                                         │
│  ┌──────────┐   ┌──────────┐   ┌──────────────────────┐│
│  │ 事件接收  │──▶│ 事件处理  │──▶│ 输出（JSON/日志/告警）││
│  └──────────┘   └──────────┘   └──────────────────────┘│
│       ▲              │                                  │
│       │              ▼                                  │
│       │         ┌──────────┐                            │
│       │         │ 规则匹配  │                            │
│       │         └──────────┘                            │
│       │                                                 │
│       │ Perf Buffer / Ring Buffer                       │
├───────┼─────────────────────────────────────────────────┤
│       │              内核空间                            │
│       │                                                 │
│  ┌────┴─────┐  ┌───────────┐  ┌───────────────────────┐│
│  │ 事件采集  │  │  过滤器   │  │   BPF Maps（缓存）    ││
│  │ (探针)   │  │           │  │                       ││
│  └──────────┘  └───────────┘  └───────────────────────┘│
│                                                         │
│  探针类型：kprobe / tracepoint / LSM                     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 6.2 Tracee 的设计理念

**「Everything is an Event」**

- 所有系统行为都抽象为事件
- 统一的事件格式
- 流水线式处理

```
事件流水线：

Raw Data ──▶ Decode ──▶ Enrich ──▶ Filter ──▶ Detect ──▶ Output
  │           │          │          │          │          │
  │           │          │          │          │          │
内核数据    解码为     添加上下文   应用过滤    规则匹配   输出告警
          结构化事件  (进程/容器)    规则
```

### 6.3 关键设计决策

| 决策点 | 选择 | 原因 |
|--------|------|------|
| 过滤在哪做 | 尽量在内核 | 减少数据传输，提高性能 |
| 事件传递方式 | Perf Buffer / Ring Buffer | 高效、支持批量 |
| 上下文缓存 | BPF Maps + 用户空间缓存 | 平衡性能和完整性 |
| ���测规则 | 用户空间执行 | 灵活性高 |

### 6.4 开发你自己的检测工具

**最小可行架构**：

```go
// 伪代码示意

func main() {
    // 1. 加载 eBPF 程序
    bpfModule := loadBPF("detector.bpf.o")

    // 2. 附加到 hook 点
    bpfModule.AttachKprobe("commit_creds", "trace_commit_creds")

    // 3. 读取事件
    events := bpfModule.GetPerfBuffer("events")

    // 4. 处理事件
    for event := range events.Read() {
        // 解码
        decoded := decodeEvent(event)

        // 丰富上下文
        enriched := enrichContext(decoded)

        // 规则匹配
        if matchRules(enriched) {
            // 输出告警
            alert(enriched)
        }
    }
}
```

---

## 快速参考卡

### eBPF 核心函数

| 函数 | 作用 |
|------|------|
| `bpf_get_current_pid_tgid()` | 获取当前 PID 和 TGID |
| `bpf_get_current_comm()` | 获取当前进程名 |
| `bpf_get_current_task()` | 获取当前 task_struct |
| `bpf_probe_read_kernel()` | 安全读取内核内存 |
| `bpf_perf_event_output()` | 发送事件到用户空间 |
| `bpf_map_lookup_elem()` | 查找 Map 元素 |
| `bpf_map_update_elem()` | 更新 Map 元素 |

### 常用 Hook 点

| 检测需求 | 推荐 Hook 点 |
|----------|--------------|
| 进程执行 | tracepoint/syscalls/sys_enter_execve |
| 权限变化 | kprobe/commit_creds |
| 文件打开 | lsm/security_file_open 或 kprobe/vfs_open |
| 网络连接 | kprobe/tcp_connect |
| 内核模块加载 | kprobe/do_init_module |

### 关键数据结构

| 结构体 | 位置 | 包含信息 |
|--------|------|----------|
| task_struct | 每个进程 | PID、进程名、父进程、cred 等 |
| cred | task_struct->cred | UID、GID、capabilities |
| file | 文件操作 | 路径、权限、inode |

---

## 下一步

理解了这些核心概念后，选择你感兴趣的方向继续学习：

| 方向 | 推荐实验 | 说明 |
|------|----------|------|
| 提权检测 | [lab-01-privilege-escalation.md](lab-01-privilege-escalation.md) | SUID 提权攻击与检测 |
| 文件监控 | [lab-02-sensitive-file-access.md](lab-02-sensitive-file-access.md) | 敏感文件访问检测 |
| 容器逃逸 | [lab-03-container-escape.md](lab-03-container-escape.md) | 容器逃逸攻击与检测 |

👉 **推荐从 [lab-01-privilege-escalation.md](lab-01-privilege-escalation.md) 开始**

---

_最后更新：2026-02-15_
